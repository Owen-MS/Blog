(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{451:function(e,t,a){"use strict";a.r(t);var s=a(45),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"理解lifecycle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#理解lifecycle"}},[e._v("#")]),e._v(" 理解lifeCycle")]),e._v(" "),a("h2",{attrs:{id:"一、前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、前言"}},[e._v("#")]),e._v(" 一、前言")]),e._v(" "),a("p",[e._v("在React生命周期之中，我们在jsx渲染时候了解了，如何从jsx - React element - fiber - Dom这样一个渲染过程。")]),e._v(" "),a("p",[e._v("这包含了React两个重要阶段，render阶段和commit阶段，React在调和（render）阶段会深度遍历React fiber树，\n目的就是发现不同的（diff），不同的地方就是接下来需要更新的地方，对于变化的组件，就回执行render函数。在一次\n调和过程完毕之后就到了commit阶段，commit阶段会创建修改真实的DOM节点。")]),e._v(" "),a("p",[e._v("如果在一次调和的过程中，法系哪里一个fiber tag = 1 类组件的情况，就回按照类组件的逻辑来处理。\n对于类组件的处理逻辑，首先判断类组件是否已经被创建过，看源码。")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("div",{staticClass:"highlight-lines"},[a("div",{staticClass:"highlighted"},[e._v(" ")]),a("br"),a("br"),a("br")]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// react-reconciler/src/ReactFiberBeginWork.js")]),e._v("\n\n\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);