(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{408:function(a,t,s){"use strict";s.r(t);var v=s(45),r=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_2-浏览器中的javascript执行机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器中的javascript执行机制"}},[a._v("#")]),a._v(" 2-浏览器中的Javascript执行机制")]),a._v(" "),s("h2",{attrs:{id:"_01-javascript是按顺序执行的吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_01-javascript是按顺序执行的吗"}},[a._v("#")]),a._v(" 01 ｜Javascript是按顺序执行的吗？")]),a._v(" "),s("p",[a._v("执行机制：先编译，再执行。")]),a._v(" "),s("h3",{attrs:{id:"变量提升-hoisting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量提升-hoisting"}},[a._v("#")]),a._v(" 变量提升（Hoisting）")]),a._v(" "),s("p",[a._v('指在Javascript代码执行过程中，Javascript引擎把变量的声明部分和函数的声明部分提升到代码开头的"行为".')]),a._v(" "),s("p",[a._v("为什么需要实现变量提升，是因为javascript代码执行之前需要先编译。")]),a._v(" "),s("h2",{attrs:{id:"_02-调用栈-为什么javascript代码会出现栈溢出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_02-调用栈-为什么javascript代码会出现栈溢出"}},[a._v("#")]),a._v(" 02｜调用栈：为什么javascript代码会出现栈溢出？")]),a._v(" "),s("p",[a._v("调用栈：利用栈解构来管理执行上下文。在执行上下文创建好后, javascript引擎将执行上下文压入栈中，\n通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。")]),a._v(" "),s("p",[a._v("是javascript引擎追踪函数执行的一个机制。")]),a._v(" "),s("h3",{attrs:{id:"栈溢出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栈溢出"}},[a._v("#")]),a._v(" 栈溢出")]),a._v(" "),s("p",[a._v("调用栈是有大小的，当入栈的执行上下文超过一定数目，javascript引擎就会报错，我们把这种错误叫做栈溢出。")]),a._v(" "),s("h2",{attrs:{id:"_03-块级作用域-var缺陷以及为什么要引入let和const"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-块级作用域-var缺陷以及为什么要引入let和const"}},[a._v("#")]),a._v(" 03｜块级作用域：var缺陷以及为什么要引入let和const？")]),a._v(" "),s("h3",{attrs:{id:"作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[a._v("#")]),a._v(" 作用域：")]),a._v(" "),s("p",[a._v("用于在何处以及如何查找变量标识符的一套机制。\n作用域是指程序中定义变量的区域，该位置决定了变量的生命周期。通俗的理解，作用域就是变量和函数的可访问范围，即作用域\n控制着变量和函数的可见性和生命周期。")]),a._v(" "),s("p",[a._v("由于Javascript的变量提升存在变量覆盖、变量污染等设计缺陷。所以ES6引入了块级作用域关键字来解决这些问题。")]),a._v(" "),s("h2",{attrs:{id:"_04-作用域和闭包-代码中出现相同的变量-javascript引擎是如何选择的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_04-作用域和闭包-代码中出现相同的变量-javascript引擎是如何选择的"}},[a._v("#")]),a._v(" 04 ｜ 作用域和闭包：代码中出现相同的变量，Javascript引擎是如何选择的？")]),a._v(" "),s("h2",{attrs:{id:"作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[a._v("#")]),a._v(" 作用域链")]),a._v(" "),s("p",[a._v("作用域链： 查找变量时我们现在当前作用域进行查找，然后去它词法阶段定义的父级作用域去查找，一直查找到全局作用域。")]),a._v(" "),s("p",[a._v("作用域链是由词法作用域决定的。")]),a._v(" "),s("p",[a._v("词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，\n通过它就能够预测代码在执行过程中如何查找标识符。")]),a._v(" "),s("p",[a._v("闭包: 当函数可以记住并能访问当前词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。")]),a._v(" "),s("h2",{attrs:{id:"_05-从javascript执行上下文的视角讲清楚this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_05-从javascript执行上下文的视角讲清楚this"}},[a._v("#")]),a._v(" 05｜从javascript执行上下文的视角讲清楚this；")]),a._v(" "),s("p",[a._v("this和执行上下文绑定，也就是说每个执行上下文中都有一个this。")]),a._v(" "),s("ul",[s("li",[a._v("当函数作为东西的方法调用时，函数中的this就是该对象。")]),a._v(" "),s("li",[a._v("当函数被正常调用时，在严格模式下，this值是undefined,非严格模式下this指向的是全局对象window。")]),a._v(" "),s("li",[a._v("嵌套函数中的this不会继承外层函数的this值。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);